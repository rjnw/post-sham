#lang racket

(require "core.rkt"
         "metadata.rkt"
         (prefix-in wf- "wf.rkt")
         "pp.rkt")

(module* signature #f
  (provide (except-out (all-defined-out) sig-md))
  (define (sig-md) (metadata:ast:signature:signature #f))
  (define (kind s [md #f])
    (unless (wf-deep-signature? s)
      (error))
    (wf-mark-deep-wf-sig! (ast:signature:kind md s)))
  (define (void [md #f]) (ast:signature:void md))
  (define (symbol [md #f]) (ast:signature:symbol md))
  (define (bool [md #f]) (ast:signature:bool md))
  (define (string [md #f]) (ast:signature:string md))
  (define (integer) (ast:signature:integer #f))
  (define (list of [md #f])
    (unless (wf-deep-signature? of)
      (error 'post:signature:wf "signature for list element not well formed. of: ~a" of))
    (wf-mark-deep-wf-sig! (ast:signature:list md of)))
  (define (cons a d [md #f])
    (unless (and (wf-deep-signature? a)
                 (wf-deep-signature? d))
      (error 'post:signature:wf "signature for cons elements not well formed. a: ~a, d: ~a" a d))
    (wf-mark-deep-wf-sig! (ast:signature:cons md a d)))
  (define (record name decls [md #f])
    (unless (and (andmap wf-deep-decl? decls)
                 (symbol? name))
      (error 'post:signature:wf "signature for record fields not well formed. name: ~a, decls: ~a" name decls))
    (wf-mark-deep-wf-sig! (ast:signature:record md name decls)))
  (define (module name defs [md #f])
    (unless (and (andmap wf-deep-decl? defs)
                 (symbol? name))
      (error 'post:signature:wf "signature for module fields not well formed. name: ~a, defs: ~a" name (map pp:decl defs)))
    (wf-mark-deep-wf-sig! (ast:signature:module md name defs)))
  (define (functor name args ret [md #f])
    (unless (and (symbol? name)
                 (andmap wf-deep-decl? args)
                 (wf-signature? ret))
      (error 'post:signature:wf "signature for functor input or return not well formed. name: ~a, args: ~a, ret: ~a" name args ret))
    (wf-mark-deep-wf-sig! (ast:signature:functor md name args ret))))

(module* expr #f
  (require (prefix-in sig: (submod ".." signature))
           (prefix-in app-builder- "app-builder.rkt"))
  (provide (all-defined-out))
  (define (void [md #f]) (ast:expr:void md (sig:void)))
  (define (functor sig bodyb [appb app-builder-generic-functor] #:md [md #f])
    (ast:expr:functor md sig bodyb appb))
  (define (module sig defb [appb app-builder-generic-module] #:md [md #f])
    (ast:expr:module md sig defb appb))
  (define (record sig vals [appb app-builder-generic-record] #:md [md #f])
    (ast:expr:record md sig vals appb))
  (define (let sig vars vals body #:md [md #f])
    (ast:expr:let md sig vars vals body))
  (define (ref sig decl #:md [md #f])
    (ast:expr:ref md sig decl))
  (define (lit sig value #:md [md #f])
    (ast:expr:lit md sig value))
  (define (app sig rator rands #:md [md #f])
    (ast:expr:app md sig rator rands))
  (define (switch sig test branches default #:md [md #f])
    (ast:expr:switch md sig test branches default))
  (define (begin sig exprs #:md [md #f])
    (ast:expr:begin md sig exprs))
  (define (while sig test body #:md [md #f])
    (ast:expr:while md sig test body)))
